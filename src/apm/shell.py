"""The main shell functionality for the APM demo."""

__all__ = ['ApmShell']

import asyncio
import asyncio.subprocess
import codecs
import inspect
from typing import Any, Coroutine

from apm import helpers


class ApmShell:
    """Class to handle (reverse) shell functionality.

    Attributes:
        tg: An asyncio TaskGroup for spawning tasks.
        reader: An asyncio StreamReader to receive shell commands.
        writer: An asyncio StreamWriter to send results.

        msg_queue: An asyncio Queue of messages to send.
        cmd_queue: An asyncio Queue of commands to process.
        shutdown_event: An asyncio Event to indicate shutdown.
        shutdown_monitor_task: Task for the shutdown monitor
        tasks: Set of currently running tasks.
    """

    tg: asyncio.TaskGroup
    reader: asyncio.StreamReader
    writer: asyncio.StreamWriter

    msg_queue: asyncio.Queue[bytes | str]
    cmd_queue: asyncio.Queue[str]
    shutdown_event: asyncio.Event
    shutdown_monitor_task: asyncio.Task | None

    def __init__(
        self,
        tg: asyncio.TaskGroup,
        reader: asyncio.StreamReader,
        writer: asyncio.StreamWriter
    ) -> None:

        self.tg = tg
        self.reader = reader
        self.writer = writer

        self.msg_queue = asyncio.Queue()
        self.cmd_queue = asyncio.Queue()
        self.shutdown_event = asyncio.Event()
        self.shutdown_monitor_task = None
        self.tasks = set()

    def start(self) -> None:
        """Runs the ApmShell."""

        # Create the msg_sender task
        self.log_debug('Creating msg_sender task')
        self.make_task(self.msg_sender())

        # Create the cmd_handler task
        self.log_debug('Creating cmd_handler task')
        self.make_task(self.cmd_handler())

        # Create the cmd_receiver task
        self.log_debug('Creating cmd_receiver task')
        self.make_task(self.cmd_receiver())

        # Start the shutdown monitor
        self.log_debug('Creating shutdown_monitor task')
        self.shutdown_monitor_task = self.tg.create_task(
            self.shutdown_monitor()
        )

        # Put the "welcome" message into the msg_queue
        self.msg_queue.put_nowait(b'APMShell, enter a command\n')

    async def cmd_handler(self) -> None:
        """Processes commands in the cmd_queue."""

        self.log_info('Starting')

        try:
            while not self.writer.is_closing():  # Loop until exited

                # Get the next command from the queue
                self.log_debug('Waiting for next command')
                cmd = await self.cmd_queue.get()
                cmd = cmd.rstrip()
                self.log_debug(f'Got command {cmd}')

                match cmd.upper()[:4]:
                    case 'QUIT':  # Check if it's a QUIT command
                        self.log_info('Received QUIT message')
                        break

                    case _:  # Otherwise assume it's a command to run
                        self.make_task(self.run_cmd(cmd))

        except asyncio.CancelledError:
            raise

        except Exception as e:
            self.log_critical(f'Exception: {e}')
            raise

        finally:
            self.log_info('Exiting')
            self.shutdown_event.set()

    async def run_cmd(self, cmd: str) -> None:
        """Runs a command (asynchronously).

        Arguments:
            cmd: The command to run.
        """

        if len(cmd) > 10:
            self.log_debug(f'Starting (cmd={cmd[:10]!r}...)')
        else:
            self.log_debug(f'Starting (cmd={cmd!r})')

        proc = await asyncio.create_subprocess_shell(
            cmd=cmd,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        # Send output that the process was created
        self.log_info(f'Created process with PID {proc.pid}')
        self.send_msg(f'Created PID {proc.pid} for cmd {cmd!r}\n')

        # Wait for the task to finish
        self.log_debug(f'PID {proc.pid} waiting')
        (stdout, stderr) = await proc.communicate()
        self.log_debug(f'PID {proc.pid} done')

        # Create the output message
        msg = helpers.format_cmd_output(proc.pid, cmd, stdout, stderr)

        # Send the message
        self.msg_queue.put_nowait(msg)

    async def msg_sender(self) -> None:
        """Responsible for sending messages from msg_queue."""

        self.log_info('Starting')

        try:
            while not self.writer.is_closing():
                # Get the next message to send
                msg = await self.msg_queue.get()

                if isinstance(msg, str):  # Encode to bytes if necessary
                    msg = codecs.encode(msg, 'latin1')

                # Debug output
                if len(msg) > 10:
                    self.log_debug(f'Sending {msg[:10]!r}...')
                else:
                    self.log_debug(f'Sending {msg!r}')

                # Send the message
                self.writer.write(msg)

                # Wait until sending done
                await self.writer.drain()

        except asyncio.CancelledError:
            raise

        except Exception as e:
            self.log_critical(f'Exception: {e}')
            raise

        finally:
            self.shutdown_event.set()
            self.log_info('Exiting')

    async def cmd_receiver(self) -> None:
        """Responsible for receving incoming commands"""

        self.log_info('Starting')

        try:
            while not self.writer.is_closing():
                cmd = await self.reader.readline()

                if not cmd:  # Exit if connection was dropped
                    self.log_debug('Empty command')
                    break

                self.cmd_queue.put_nowait(codecs.decode(cmd, 'latin1'))

        except asyncio.CancelledError:
            raise

        except Exception as e:
            self.log_critical(f'Exception: {e}')
            raise

        finally:
            self.shutdown_event.set()
            self.log_info('Exiting')

    async def shutdown_monitor(self) -> None:
        """Monitors shutdown_event, and terminates when event is set"""

        self.log_info('Starting')

        # Wait for the shutdown event to be set
        await self.shutdown_event.wait()
        self.log_info('Shutting down')

        # Shutdown any tasks
        for task in self.tasks:
            task.cancel()

        self.log_info('Exiting')

    #
    # Utilities related to the shell functionality
    #

    def make_task(self, coro: Coroutine[Any, Any, None]) -> None:
        """Creates a task for a coroutine, and adds it to the tasks set."""

        # Create the asyncio task
        task = self.tg.create_task(coro)

        # Add it to the set of tasks
        self.tasks.add(task)

        # Remove the task from the set of tasks when it is done
        task.add_done_callback(self.tasks.discard)

        # Generate debug output
        task_id = task.get_name().split('-')[-1]
        coro_name = coro.cr_code.co_name
        self.log_debug(f'Created task for {coro_name}[{task_id}]')

    def send_msg(self, msg: str | bytes) -> None:
        """Sends an informational message to the remote side."""

        if isinstance(msg, str):
            msg = codecs.encode(msg, 'latin1')

        self.msg_queue.put_nowait(b' '.join([b'[*]', msg]))

    #
    # Logging related utilities (unrelated to the shell functionality)
    #

    def _get_logging_caller(self) -> str:
        """Gets the name of the caller for logging."""

        caller_name = inspect.stack()[2].function
        return '.'.join([self.__class__.__name__, caller_name])

    def log_debug(self, msg: str) -> None:
        """Logs a debug message."""

        helpers.debug_msg(msg=msg, caller_name=self._get_logging_caller())

    def log_info(self, msg: str) -> None:
        """Logs an info message."""

        helpers.info_msg(msg=msg, caller_name=self._get_logging_caller())

    def log_critical(self, msg: str) -> None:
        """Logs a critical message."""

        helpers.critical_msg(
            msg=msg, caller_name=self._get_logging_caller()
        )
