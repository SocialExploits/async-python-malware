"""Helper / utility code for the APM demo."""
import asyncio
import codecs
import inspect
import io
import logging


#
# Global variables
#

# Logger root
LOGGER_ROOT = 'APM'

# Global logger
LOGGER: logging.Logger = logging.getLogger(LOGGER_ROOT)


#
# Logging related code
#

class ApmFilter(logging.Filter):
    """Provides the task_id context variable for logging."""

    def filter(self, record: logging.LogRecord) -> bool:
        try:
            task = asyncio.current_task()
            if task is not None:
                task_id = task.get_name().split('-')[-1]
            else:
                task_id = '-'

            record.task_id = task_id
        except RuntimeError:
            record.task_id = '-'

        return True


def set_up_logging(verbosity: int = 0) -> None:
    """Sets up logging.

    Arguments:
        verbosity: How verbose the output should be.
    """

    levels = [logging.CRITICAL, logging.INFO, logging.DEBUG]
    log_level = levels[min(verbosity, len(levels)-1)]
    LOGGER.setLevel(log_level)
    handler = logging.StreamHandler()
    handler.setLevel(log_level)
    formatter = logging.Formatter(
        fmt='{levelname:5s} {caller_name}[{task_id}]: {msg}', style='{'
    )
    handler.setFormatter(formatter)
    handler.addFilter(ApmFilter())
    LOGGER.addHandler(handler)


def debug_msg(msg: str, caller_name: str = '') -> None:
    """Logs a debug message.

    Arguments:
        msg: The message to log.
        caller_name: Optional caller name (default: guess).
    """

    if not caller_name:
        caller_name = inspect.stack()[1].function

    LOGGER.debug(msg, extra={'caller_name': caller_name})


def info_msg(msg: str, caller_name: str = '') -> None:
    """Logs an info message.

    Arguments:
        msg: The message to log.
        caller_name: Optional caller name (default: guess).
    """

    if not caller_name:
        caller_name = inspect.stack()[1].function

    LOGGER.info(msg, extra={'caller_name': caller_name})


def critical_msg(msg: str, caller_name: str = '') -> None:
    """Logs a critical message.

    Arguments:
        msg: The message to log.
        caller_name: Optional caller name (default: guess).
    """

    if not caller_name:
        caller_name = inspect.stack()[1].function

    LOGGER.critical(msg, extra={'caller_name': caller_name})


#
# Formatting utilities
#

def format_cmd_output(pid: int, cmd: str, stdout: bytes, stderr: bytes) -> str:
    """Formats output from a command.

    Arguments:
        pid: The PID the command ran as.
        cmd: The command that ran.
        stdout: The standard output.
        stderr: The standard err.

    Returns:
        A string suitable to send to the remote side.
    """

    stdout_str = io.StringIO(codecs.decode(stdout, 'latin1'))
    stderr_str = io.StringIO(codecs.decode(stderr, 'latin1'))

    result = [
        f'[*] OUTPUT (pid = {pid}, cmd = {cmd!r})',
        '[*] STDOUT:'
    ]
    result.extend([line.rstrip() for line in stdout_str.readlines()])
    result.append('')
    result.append('[*] STDERR:')
    result.extend([line.rstrip() for line in stderr_str.readlines()])
    result.append('\n')

    return '\n'.join(result)
